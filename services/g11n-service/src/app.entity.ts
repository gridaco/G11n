import * as dynamoose from 'dynamoose';
import { nanoid } from 'nanoid';

import { AssetType } from '@bridged.xyz/client-sdk/lib/assets';
import {
  keyNameFormatValidation,
  placeholderNameFormatValidation,
  PlaceholderType,
} from '@bridged.xyz/client-sdk/lib/g11n';

/**
 * the key manifest for globallized assets.
 * unique with ( projectId && type && keyName )
 */
export interface KeyRecord {
  /**
   * the id of this key generated by server
   */
  id: string;

  /**
   * the project of this key being assosiated
   */
  projectId: string;

  /**
   * name of the key, commonly said as just "key" on the client side.
   */
  keyName: string;

  /**
   * type of asset to be linked with this key.
   */
  type: AssetType;

  /**
   * configuration of availability of this key being embedded by other key.
   * defaults to false
   *
   * if embeddable set to true, this key will be visible for search results of key.
   * if embeddable 'changed' to false, all the referening assets will be replaced with last known value & localse of this key's asset.
   */
  embeddable: boolean;

  /**
   * the id of variant asset 1:1 matched to this key
   */
  linkedAssetId?: string;
}

/**
 * place holder used for creating templated text, e.g. - "hi {USER_NAME}, glad to meet you here again"
 */
export interface PlaceHolderRecord {
  id: string;
  name: string;
  type: PlaceholderType;
}

/**
 * maps scene's layer and asset's key together
 */
export interface LayerKeyMapRecord {
  id: string;

  /**
   * id of project this record belongs to
   */
  projectId: string;

  /**
   * the id of the key
   */
  keyId: string;

  /**
   * the id of the registered scene, which holds this layer
   */
  sceneId: string;

  /**
   * the id of the layer
   */
  layerId: string;
}

const PlaceholderSchema = new dynamoose.Schema(
  {
    id: {
      type: String,
      hashKey: true,
      required: true,
      default: () => nanoid(),
    },
    name: {
      type: String,
      required: true,
    },
    type: {
      type: String,
      enum: ['NUMBER', 'DATE', 'BOOLEAN', 'TEXT', 'CURRENCY'],
      required: true,
    },
  },
  {
    saveUnknown: false,
  }
);

const LayerKeyMapSchema = new dynamoose.Schema({
  id: {
    type: String,
    required: true,
  },
  projectId: {
    type: String,
    required: true,
    index: {
      name: 'projectIndex',
      global: true,
    },
  },
  keyId: {
    type: String,
    required: true,
    index: {
      name: 'keyIndex',
      global: true,
    },
  },
  sceneId: {
    type: String,
    required: true,
    index: {
      name: 'sceneIndex',
      global: true,
    },
  },
  layerId: {
    type: String,
    required: true,
    index: {
      name: 'layerIndex',
      global: true,
    },
  },
});

const KeySchema = new dynamoose.Schema(
  {
    id: {
      type: String,
      required: true,
      hashKey: true,
      default: () => nanoid(),
    },
    projectId: {
      type: String,
      required: true,
    },
    keyName: {
      type: String,
      required: true,
      // validate: (v: string) => keyNameFormatValidation(v)
    },
    type: {
      type: String,
      enum: [
        'URI',
        'TEXT',
        'IMAGE',
        'ICON',
        'ILLUST',
        'COLOR',
        'FILE',
        'UNKNOWN',
      ],
      required: true,
    },
    embeddable: {
      type: Boolean,
      default: false,
      required: true,
    },
    linkedAssetId: {
      type: String,
      required: false,
    },
  },
  {
    saveUnknown: false,
  }
);

const KEY_TABLE_NAME = process.env.DYNAMODB_KEY_TABLE;
export const KeyModel = dynamoose.model(KEY_TABLE_NAME, KeySchema, {
  create: false,
});

const LAYER_KEY_MAP_TABLE = process.env.DYNAMODB_LAYER_KEY_MAP_TABLE;

export const LayerKeyMapModel = dynamoose.model(
  LAYER_KEY_MAP_TABLE,
  LayerKeyMapSchema,
  {
    create: false,
  }
);
